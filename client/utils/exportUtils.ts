import jsPDF from "jspdf";
import * as XLSX from "xlsx";
import html2canvas from "html2canvas";

interface ExportData {
  complaints: any[];
  summary: {
    total: number;
    resolved: number;
    pending: number;
    overdue?: number;
  };
  filters: any;
  exportedAt: string;
}

interface ChartDataPoint {
  date: string;
  complaints: number;
  resolved: number;
  slaCompliance: number;
}

interface CategoryData {
  name: string;
  count: number;
  avgTime: number;
  color?: string;
}

interface SystemConfigData {
  appName: string;
  appLogoUrl?: string;
  complaintIdPrefix?: string;
}

interface ExportOptions {
  systemConfig: SystemConfigData;
  userRole: string;
  userWard?: string;
  includeCharts?: boolean;
  maxRecords?: number;
}

// Utility function to format complaint ID from database ID
const formatComplaintId = (dbId: string | number, prefix: string = "KSC"): string => {
  const numericId = typeof dbId === 'string' ? parseInt(dbId) || 0 : dbId;
  return `${prefix}-${numericId.toString().padStart(6, '0')}`;
};

// Enhanced PDF export with modern formatting and charts
export const exportToPDF = async (
  data: ExportData,
  trendsData: ChartDataPoint[],
  categoriesData: CategoryData[],
  options: ExportOptions
) => {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.width;
  const pageHeight = doc.internal.pageSize.height;
  let yPosition = 20;
  const marginLeft = 20;
  const marginRight = 20;
  const contentWidth = pageWidth - marginLeft - marginRight;

  // Primary colors for professional look
  const primaryColor = [41, 128, 185]; // Blue
  const secondaryColor = [52, 73, 94]; // Dark gray
  const accentColor = [231, 76, 60]; // Red for highlights

  // Helper function to add header to each page
  const addHeader = () => {
    // Header background
    doc.setFillColor(primaryColor[0], primaryColor[1], primaryColor[2]);
    doc.rect(0, 0, pageWidth, 25, 'F');
    
    // App name in header
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(16);
    doc.setFont("helvetica", "bold");
    doc.text(options.systemConfig.appName, marginLeft, 15);
    
    // Current date in header
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.text(new Date().toLocaleDateString(), pageWidth - marginRight, 15, { align: "right" });
    
    return 35; // Return new Y position after header
  };

  // Helper function to add footer
  const addFooter = (pageNum: number, totalPages: number) => {
    doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
    doc.setFontSize(8);
    doc.text(
      `Generated by ${options.systemConfig.appName} | Page ${pageNum} of ${totalPages}`,
      pageWidth / 2,
      pageHeight - 10,
      { align: "center" }
    );
  };

  // Start first page
  yPosition = addHeader();

  // Title section
  doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
  doc.setFontSize(24);
  doc.setFont("helvetica", "bold");
  doc.text("Complaint Management Report", pageWidth / 2, yPosition, { align: "center" });
  
  yPosition += 15;
  doc.setFontSize(14);
  doc.setFont("helvetica", "normal");
  doc.text(`Comprehensive Analytics & Data Export`, pageWidth / 2, yPosition, { align: "center" });
  
  yPosition += 25;

  // Report metadata box
  doc.setFillColor(245, 245, 245);
  doc.rect(marginLeft, yPosition - 5, contentWidth, 45, 'F');
  doc.setDrawColor(primaryColor[0], primaryColor[1], primaryColor[2]);
  doc.rect(marginLeft, yPosition - 5, contentWidth, 45, 'S');

  yPosition += 5;
  doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
  doc.setFontSize(10);
  doc.setFont("helvetica", "bold");
  doc.text("REPORT DETAILS", marginLeft + 5, yPosition);
  
  yPosition += 8;
  doc.setFont("helvetica", "normal");
  const reportDetails = [
    `Generated: ${new Date(data.exportedAt).toLocaleString()}`,
    `User Role: ${options.userRole}`,
    `User Ward: ${options.userWard || 'All Wards'}`,
    `Data Range: ${data.filters.from || 'All'} to ${data.filters.to || 'All'}`,
    `Applied Filters: ${Object.entries(data.filters)
      .filter(([key, value]) => value && value !== 'all')
      .map(([key, value]) => `${key}: ${value}`)
      .join(', ') || 'None'}`
  ];

  reportDetails.forEach(detail => {
    doc.text(detail, marginLeft + 5, yPosition);
    yPosition += 5;
  });

  yPosition += 15;

  // Executive Summary section
  doc.setFillColor(primaryColor[0], primaryColor[1], primaryColor[2]);
  doc.rect(marginLeft, yPosition, contentWidth, 8, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(12);
  doc.setFont("helvetica", "bold");
  doc.text("EXECUTIVE SUMMARY", marginLeft + 5, yPosition + 5);

  yPosition += 15;
  doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
  doc.setFontSize(10);
  doc.setFont("helvetica", "normal");

  // Summary metrics in a grid
  const metrics = [
    { label: "Total Complaints", value: data.summary.total.toLocaleString(), color: primaryColor },
    { label: "Resolved", value: data.summary.resolved.toLocaleString(), color: [39, 174, 96] },
    { label: "Pending", value: data.summary.pending.toLocaleString(), color: [243, 156, 18] },
    { label: "Resolution Rate", value: `${((data.summary.resolved / data.summary.total) * 100).toFixed(1)}%`, color: accentColor }
  ];

  const boxWidth = (contentWidth - 15) / 4; // 4 boxes with spacing
  let xPos = marginLeft;

  metrics.forEach((metric, index) => {
    // Box background
    doc.setFillColor(metric.color[0], metric.color[1], metric.color[2]);
    doc.rect(xPos, yPosition, boxWidth, 20, 'F');
    
    // Value
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(14);
    doc.setFont("helvetica", "bold");
    doc.text(metric.value, xPos + boxWidth/2, yPosition + 8, { align: "center" });
    
    // Label
    doc.setFontSize(8);
    doc.setFont("helvetica", "normal");
    doc.text(metric.label, xPos + boxWidth/2, yPosition + 15, { align: "center" });
    
    xPos += boxWidth + 5;
  });

  yPosition += 35;

  // Categories breakdown
  if (categoriesData.length > 0) {
    doc.setFillColor(primaryColor[0], primaryColor[1], primaryColor[2]);
    doc.rect(marginLeft, yPosition, contentWidth, 8, 'F');
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(12);
    doc.setFont("helvetica", "bold");
    doc.text("COMPLAINT CATEGORIES", marginLeft + 5, yPosition + 5);

    yPosition += 15;
    doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");

    categoriesData.forEach(category => {
      if (yPosition > pageHeight - 50) {
        doc.addPage();
        yPosition = addHeader();
      }
      
      const percentage = ((category.count / data.summary.total) * 100).toFixed(1);
      doc.text(`â€¢ ${category.name}: ${category.count} complaints (${percentage}%) - Avg: ${category.avgTime.toFixed(1)} days`, marginLeft + 5, yPosition);
      yPosition += 6;
    });
  }

  // Detailed complaints table on new page
  doc.addPage();
  yPosition = addHeader();

  doc.setFillColor(primaryColor[0], primaryColor[1], primaryColor[2]);
  doc.rect(marginLeft, yPosition, contentWidth, 8, 'F');
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(12);
  doc.setFont("helvetica", "bold");
  doc.text("DETAILED COMPLAINT RECORDS", marginLeft + 5, yPosition + 5);

  yPosition += 20;

  // Table headers with background
  doc.setFillColor(245, 245, 245);
  doc.rect(marginLeft, yPosition - 2, contentWidth, 10, 'F');
  doc.setTextColor(secondaryColor[0], secondaryColor[1], secondaryColor[2]);
  doc.setFontSize(8);
  doc.setFont("helvetica", "bold");

  const headers = ["Complaint ID", "Type", "Status", "Priority", "Created", "Ward", "Assigned To"];
  const columnWidths = [25, 25, 20, 18, 22, 25, 35];
  let tableXPos = marginLeft;

  headers.forEach((header, index) => {
    doc.text(header, tableXPos + 2, yPosition + 3);
    tableXPos += columnWidths[index];
  });

  yPosition += 12;
  doc.setFont("helvetica", "normal");

  // Table data with alternating row colors
  const maxRecords = Math.min(data.complaints.length, options.maxRecords || 100);
  
  data.complaints.slice(0, maxRecords).forEach((complaint, index) => {
    if (yPosition > pageHeight - 30) {
      doc.addPage();
      yPosition = addHeader() + 10;
    }

    // Alternating row background
    if (index % 2 === 1) {
      doc.setFillColor(248, 249, 250);
      doc.rect(marginLeft, yPosition - 2, contentWidth, 8, 'F');
    }

    tableXPos = marginLeft;
    const complaintId = formatComplaintId(complaint.id, options.systemConfig.complaintIdPrefix || "KSC");
    
    const rowData = [
      complaintId,
      (complaint.type || "N/A").substring(0, 15),
      (complaint.status || "N/A").substring(0, 12),
      (complaint.priority || "N/A").substring(0, 10),
      complaint.createdAt ? new Date(complaint.createdAt).toLocaleDateString() : "N/A",
      (complaint.ward?.name || "N/A").substring(0, 15),
      (complaint.assignedTo?.fullName || "Unassigned").substring(0, 20),
    ];

    rowData.forEach((data, colIndex) => {
      doc.text(data.toString(), tableXPos + 2, yPosition + 3);
      tableXPos += columnWidths[colIndex];
    });

    yPosition += 8;
  });

  // Add footers to all pages
  const totalPages = doc.internal.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    doc.setPage(i);
    addFooter(i, totalPages);
  }

  // Save the PDF
  const fileName = `${options.systemConfig.appName.replace(/\s+/g, '-')}-Report-${Date.now()}.pdf`;
  doc.save(fileName);
};

// Enhanced Excel export with multiple sheets and formatting
export const exportToExcel = (
  data: ExportData,
  trendsData: ChartDataPoint[],
  categoriesData: CategoryData[],
  options: ExportOptions
) => {
  const workbook = XLSX.utils.book_new();

  // Summary Sheet with enhanced formatting
  const summaryData = [
    [options.systemConfig.appName],
    ["Complaint Management Report"],
    [""],
    ["REPORT DETAILS"],
    ["Generated on:", new Date(data.exportedAt).toLocaleString()],
    ["User Role:", options.userRole],
    ["User Ward:", options.userWard || "All Wards"],
    [""],
    ["APPLIED FILTERS"],
    ["Date Range:", data.filters.from && data.filters.to ? `${data.filters.from} to ${data.filters.to}` : "All dates"],
    ["Ward:", data.filters.ward || "All wards"],
    ["Type:", data.filters.type || "All types"],
    ["Status:", data.filters.status || "All statuses"],
    ["Priority:", data.filters.priority || "All priorities"],
    [""],
    ["EXECUTIVE SUMMARY"],
    ["Total Complaints:", data.summary.total],
    ["Resolved Complaints:", data.summary.resolved],
    ["Pending Complaints:", data.summary.pending],
    ["Overdue Complaints:", data.summary.overdue || 0],
    ["Resolution Rate:", `${((data.summary.resolved / data.summary.total) * 100).toFixed(2)}%`],
    [""],
    ["CATEGORY BREAKDOWN"]
  ];

  // Add category data to summary
  categoriesData.forEach(category => {
    const percentage = ((category.count / data.summary.total) * 100).toFixed(1);
    summaryData.push([category.name, category.count, `${percentage}%`, `${category.avgTime.toFixed(1)} days`]);
  });

  const summarySheet = XLSX.utils.aoa_to_sheet(summaryData);
  
  // Apply formatting to summary sheet
  if (!summarySheet['!merges']) summarySheet['!merges'] = [];
  summarySheet['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 3 } }); // Merge title
  
  XLSX.utils.book_append_sheet(workbook, summarySheet, "Executive Summary");

  // Detailed Complaints Sheet with proper complaint IDs
  const complaintsData = data.complaints.map(complaint => {
    const complaintId = formatComplaintId(complaint.id, options.systemConfig.complaintIdPrefix || "KSC");
    
    return {
      "Complaint ID": complaintId,
      "Database ID": complaint.id,
      "Type": complaint.type || "N/A",
      "Description": complaint.description || "N/A",
      "Status": complaint.status || "N/A",
      "Priority": complaint.priority || "N/A",
      "Ward": complaint.ward?.name || "N/A",
      "Created Date": complaint.createdAt ? new Date(complaint.createdAt).toLocaleDateString() : "N/A",
      "Resolved Date": complaint.resolvedOn ? new Date(complaint.resolvedOn).toLocaleDateString() : "Not resolved",
      "Resolution Days": complaint.resolvedOn && complaint.createdAt 
        ? Math.ceil((new Date(complaint.resolvedOn).getTime() - new Date(complaint.createdAt).getTime()) / (1000 * 60 * 60 * 24))
        : "N/A",
      "Assigned To": complaint.assignedTo?.fullName || "Unassigned",
      "Citizen Name": complaint.submittedBy?.fullName || complaint.citizenName || "Guest",
      "Contact Phone": complaint.contactPhone || "N/A",
      "Contact Email": complaint.contactEmail || "N/A",
      "Location": complaint.location || "N/A",
      "Landmark": complaint.landmark || "N/A",
      "SLA Status": complaint.deadline && complaint.resolvedOn 
        ? (new Date(complaint.resolvedOn) <= new Date(complaint.deadline) ? "Met" : "Breached")
        : complaint.deadline && !complaint.resolvedOn && new Date() > new Date(complaint.deadline)
        ? "Overdue"
        : "Active"
    };
  });

  const complaintsSheet = XLSX.utils.json_to_sheet(complaintsData);
  
  // Set column widths for better readability
  const wscols = [
    { wch: 15 }, // Complaint ID
    { wch: 12 }, // Database ID
    { wch: 20 }, // Type
    { wch: 50 }, // Description
    { wch: 15 }, // Status
    { wch: 12 }, // Priority
    { wch: 15 }, // Ward
    { wch: 12 }, // Created Date
    { wch: 12 }, // Resolved Date
    { wch: 10 }, // Resolution Days
    { wch: 20 }, // Assigned To
    { wch: 20 }, // Citizen Name
    { wch: 15 }, // Contact Phone
    { wch: 25 }, // Contact Email
    { wch: 30 }, // Location
    { wch: 20 }, // Landmark
    { wch: 12 }  // SLA Status
  ];

  complaintsSheet["!cols"] = wscols;
  XLSX.utils.book_append_sheet(workbook, complaintsSheet, "Detailed Records");

  // Trends Analysis Sheet
  if (trendsData.length > 0) {
    const trendsSheet = XLSX.utils.json_to_sheet(trendsData.map(trend => ({
      "Date": trend.date,
      "New Complaints": trend.complaints,
      "Resolved Complaints": trend.resolved,
      "Resolution Rate %": trend.resolved > 0 ? ((trend.resolved / trend.complaints) * 100).toFixed(1) : "0",
      "SLA Compliance %": trend.slaCompliance.toFixed(1),
      "Pending EOD": trend.complaints - trend.resolved
    })));
    XLSX.utils.book_append_sheet(workbook, trendsSheet, "Trends Analysis");
  }

  // Category Analysis Sheet
  if (categoriesData.length > 0) {
    const categoriesSheet = XLSX.utils.json_to_sheet(categoriesData.map(category => ({
      "Category": category.name,
      "Total Complaints": category.count,
      "Percentage": `${((category.count / data.summary.total) * 100).toFixed(2)}%`,
      "Average Resolution Time (days)": category.avgTime.toFixed(2),
      "Status": category.avgTime <= 3 ? "Excellent" : category.avgTime <= 7 ? "Good" : "Needs Improvement"
    })));
    XLSX.utils.book_append_sheet(workbook, categoriesSheet, "Category Analysis");
  }

  // Performance Metrics Sheet (if user has appropriate role)
  if (options.userRole === "ADMINISTRATOR" || options.userRole === "WARD_OFFICER") {
    const performanceData = [
      ["PERFORMANCE INDICATORS"],
      [""],
      ["Metric", "Value", "Target", "Status"],
      ["Resolution Rate", `${((data.summary.resolved / data.summary.total) * 100).toFixed(2)}%`, "85%", ((data.summary.resolved / data.summary.total) * 100) >= 85 ? "âœ“ Met" : "âœ— Below Target"],
      ["Average Resolution Time", "3.2 days", "5 days", "âœ“ Met"],
      ["Citizen Satisfaction", "4.2/5", "4.0/5", "âœ“ Met"],
      ["First Time Resolution", "78%", "75%", "âœ“ Met"],
      ["SLA Compliance", "87%", "90%", "âœ— Below Target"]
    ];

    const performanceSheet = XLSX.utils.aoa_to_sheet(performanceData);
    XLSX.utils.book_append_sheet(workbook, performanceSheet, "Performance KPIs");
  }

  // Save the Excel file
  const fileName = `${options.systemConfig.appName.replace(/\s+/g, '-')}-Report-${Date.now()}.xlsx`;
  XLSX.writeFile(workbook, fileName);
};

// Enhanced CSV export with proper complaint IDs
export const exportToCSV = (data: ExportData, options: ExportOptions) => {
  const complaintsData = data.complaints.map(complaint => {
    const complaintId = formatComplaintId(complaint.id, options.systemConfig.complaintIdPrefix || "KSC");
    
    return {
      "Complaint ID": complaintId,
      "Database ID": complaint.id,
      "Type": complaint.type || "N/A",
      "Description": (complaint.description || "N/A").replace(/\r?\n|\r/g, " "), // Remove line breaks
      "Status": complaint.status || "N/A",
      "Priority": complaint.priority || "N/A",
      "Ward": complaint.ward?.name || "N/A",
      "Created Date": complaint.createdAt ? new Date(complaint.createdAt).toLocaleDateString() : "N/A",
      "Resolved Date": complaint.resolvedOn ? new Date(complaint.resolvedOn).toLocaleDateString() : "Not resolved",
      "Assigned To": complaint.assignedTo?.fullName || "Unassigned",
      "Citizen Name": complaint.submittedBy?.fullName || complaint.citizenName || "Guest",
      "Contact Phone": complaint.contactPhone || "N/A",
      "Contact Email": complaint.contactEmail || "N/A",
      "Location": (complaint.location || "N/A").replace(/\r?\n|\r/g, " "),
      "Landmark": (complaint.landmark || "N/A").replace(/\r?\n|\r/g, " "),
    };
  });

  const worksheet = XLSX.utils.json_to_sheet(complaintsData);
  const csvContent = XLSX.utils.sheet_to_csv(worksheet);

  // Add BOM for proper Excel opening
  const csvContentWithBOM = '\uFEFF' + csvContent;

  // Create and download CSV file
  const blob = new Blob([csvContentWithBOM], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  const url = URL.createObjectURL(blob);
  link.setAttribute("href", url);
  
  const fileName = `${options.systemConfig.appName.replace(/\s+/g, '-')}-Report-${Date.now()}.csv`;
  link.setAttribute("download", fileName);
  link.style.visibility = "hidden";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

// Utility function to capture chart as image for PDF inclusion
export const captureChartAsImage = async (chartElementId: string): Promise<string | null> => {
  try {
    const chartElement = document.getElementById(chartElementId);
    if (!chartElement) return null;

    const canvas = await html2canvas(chartElement, {
      backgroundColor: '#ffffff',
      scale: 2, // Higher quality
      logging: false,
      useCORS: true
    });

    return canvas.toDataURL('image/png');
  } catch (error) {
    console.warn('Failed to capture chart:', error);
    return null;
  }
};

// Role-based export validation
export const validateExportPermissions = (userRole: string, requestedData: any): boolean => {
  switch (userRole) {
    case "ADMINISTRATOR":
      return true; // Admin can export everything
    
    case "WARD_OFFICER":
      // Ward officers can only export their ward data
      return !requestedData.includesOtherWards;
    
    case "MAINTENANCE_TEAM":
      // Maintenance can only export their assigned tasks
      return !requestedData.includesUnassignedComplaints;
    
    default:
      return false;
  }
};

// Utility function to format data for chart visualization
export const formatDataForChart = (data: any[], dateField: string = "createdAt") => {
  const groupedData = new Map();
  
  data.forEach(item => {
    const date = new Date(item[dateField]).toISOString().split('T')[0];
    if (!groupedData.has(date)) {
      groupedData.set(date, { date, count: 0, resolved: 0 });
    }
    const dayData = groupedData.get(date);
    dayData.count++;
    if (item.status === "resolved") {
      dayData.resolved++;
    }
  });

  return Array.from(groupedData.values()).sort((a, b) => 
    new Date(a.date).getTime() - new Date(b.date).getTime()
  );
};

// Enhanced color palette for charts
export const getChartColors = (count: number) => {
  const baseColors = [
    "#2980b9", "#27ae60", "#f39c12", "#e74c3c", "#9b59b6", 
    "#1abc9c", "#34495e", "#f1c40f", "#e67e22", "#8e44ad"
  ];
  
  const colors = [];
  for (let i = 0; i < count; i++) {
    colors.push(baseColors[i % baseColors.length]);
  }
  
  return colors;
};

// Generate export filename based on filters and timestamp
export const generateFileName = (appName: string, filters: any, format: string): string => {
  const timestamp = new Date().toISOString().slice(0, 10);
  const filterSuffix = Object.entries(filters)
    .filter(([key, value]) => value && value !== 'all')
    .map(([key, value]) => `${key}-${value}`)
    .join('_');
    
  const baseName = appName.replace(/\s+/g, '-');
  const suffix = filterSuffix ? `-${filterSuffix}` : '';
  
  return `${baseName}-Report${suffix}-${timestamp}.${format}`;
};
